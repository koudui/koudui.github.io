<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java 内部类</title>
      <link href="/2018/05/11/Java-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <content type="html"><![CDATA[<p>[TOC]</p><p>*感谢：<a href="https://www.nowcoder.com/profile/939213" target="_blank" rel="noopener">https://www.nowcoder.com/profile/939213</a></p><p>#1 为什么使用内部类<br>使用内部类最吸引人的原因是：每一个内部类都能独立继承一个（接口的）实现，所以无论外部类是否继承了某个（接口的）实现，对内部类来说都没有影响。<strong>使用内部类最大的优点就是能实现多重继承</strong>，并且内部类还具有以下特征：<br>1）内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象相互独立。<br>2）在单个外围类中，可以让多个内部类以不同的方式继承同一个类或者实现同一个接口。<br>3）创建内部类的时刻并不依赖于外围类对象的创建。<br>4）内部类没有令人迷惑的”is-a”关系，每一个内部类都是一个独立的主体。<br>5）内部类提供了更好的封装，出来外围类，其他类都不能直接访问。<br><a id="more"></a></p><p>#2内部类分类</p><p>##2.1成员内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">99</span>;</span><br><span class="line">        String name = <span class="string">"Coco"</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            String name = <span class="string">"Jayden"</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(Outer.<span class="keyword">this</span>.name);</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                System.out.println(age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">            Inner in = o.new Inner();</span><br><span class="line">            in.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Coco</span><br><span class="line">Jayden</span><br><span class="line">99</span><br></pre></td></tr></table></figure></p><p>1.Inner定义在Outer内部，相当于Outer的一个类成员变量，Inner可以使用任何访问控制符，包括<code>public</code>，<code>private</code>，<code>protected</code>。<br>2.Inner中定义的方法可以直接访问Outer中的数据，如show()方法，并且不受访问控制符的影响。<br>3.定义了成员内部类后，必须使用外部类对象来创建内部类对象，不能直接使用new创建一个内部类对象，即 <code>内部类 对象名=外部类对象.new</code> 内部类()<br>4.上面的程序在编译后会生成两个.class文件，Outer.class和Outer$Inner.class<br>5.成员内部类中不能存在有静态变量和方法，但可以定义常量：<br>1）常量在编译时就确定了，放在常量池中。<br>2）非静态内部类是依赖于外部类实例的，而静态变量和方法不依赖于对象，而与类有关。<br><strong>敲黑板：</strong><br>1）外部类不能直接访问内部类的成员和方法，可先创建内部类对象，然后根据内部类对象来访问其成员和方法。<br>2）如果内部类和外部类具有相同的变量和方法，内部类默认访问自己的变量和方法，如果需要访问外部类的成员和方法，可以使用 <code>外部类.this.变量名（方法名）</code></p><p>##2.2静态内部类（static）：<br>1.静态内部类不能直接访问外部类的非静态成员，但是可以通过<code>new 外部类().成员</code>的方式来访问。<br>2.如果外部类的静态成员和内部类成员名称相同，可通过<code>外部类.静态成员</code>的方式来访问；如果外部类的静态成员和内部类成员名称不同，则通过<code>成员名</code>直接访问外部类的静态成员。<br>3.创建静态内部类对象时，可以不通过外部类对象，直接<code>内部类 对象名=new 内部类()</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">99</span>;</span><br><span class="line">            <span class="keyword">static</span> String name = <span class="string">"Coco"</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">                String name = <span class="string">"Jayden"</span>;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    System.out.println(Outer.name);</span><br><span class="line">                    System.out.println(name);                  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">                Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">                i.show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Coco</span><br><span class="line">Jayden</span><br></pre></td></tr></table></figure></p><p>##2.3方法内部类：仅作用于方法内，方法外不能访问该内部类<br>1）局部内部类就像是方法里的一个局部变量，是不能有public，private，protected，static等修饰的。<br>2）<strong>只能访问方法内部的final类型变量</strong>，因为：<br>当方法被调用完毕后，局部变量就消亡了，但是内部类可能还存在，直到没有引用时才消亡，此时会发生一种情况，就是内部类要访问一个不存在的局部变量；<br>使用final修饰符不仅会保持对象的引用不会改变，而且编译器还会持续维护这个对象在回调中的生命周期；<br>局部内部类并不是直接调用方法传过来的参数，而是内部类将方法传过来的参数通过自己的构造器备份到了自己内部，自己的方法调用的是自己的属性而不是外来的参数；<br>防止被篡改，保证局部内部类得到的值不会改变。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       使用的形参为何要为 final???</span></span><br><span class="line"><span class="comment">        在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，</span></span><br><span class="line"><span class="comment">        也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，</span></span><br><span class="line"><span class="comment">        毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解</span></span><br><span class="line"><span class="comment">        和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">25</span>;</span><br><span class="line">               <span class="keyword">int</span> b = <span class="number">13</span>;</span><br><span class="line">               <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">                   <span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">                       System.out.println(<span class="string">"访问外部类:"</span> + a);</span><br><span class="line">                       System.out.println(<span class="string">"访问内部类:"</span> + c);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">               i.print();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">               Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">               o.show();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>3)注意:<strong>在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final</strong>,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能<br><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html</a><br>反编译jdk8编译之后的class文件,发现内部类引用外部的局部变量都是 final 修饰的</p><p>##2.4匿名内部类：<br>1）匿名内部类时直接使用<code>new</code>来生成一个对象的引用。<br>2）对于匿名类有一个缺陷，就是它仅能使用一次，不能重复使用。<br>3）使用匿名内部类时，必须并且只能是继承一个类或者实现一个接口，但是两者不可兼得。<br>4）匿名内部类中不能定义构造函数，也不能有静态成员和静态方法。<br>5）匿名内部类不是抽象的，必须实现继承的类或实现的接口的所有抽象方法。<br>6)匿名内部类初始化:使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>   num,String str2)</span></span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> InnerClass()&#123;</span><br><span class="line">                   <span class="keyword">int</span> number = num + <span class="number">3</span>;</span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">                       <span class="keyword">return</span> number;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;;        <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">               OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">               InnerClass inner = out.getInnerClass(<span class="number">2</span>, <span class="string">"chenssy"</span>);</span><br><span class="line">               System.out.println(inner.getNumber());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="class"><span class="keyword">interface</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p><p>#3总结<br>细细想来，内部类还真是不简单呢，你看看这是写了多大的篇幅。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为eclipse添加反编译插件</title>
      <link href="/2018/04/24/%E4%B8%BAeclipse%E6%B7%BB%E5%8A%A0%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8F%92%E4%BB%B6/"/>
      <content type="html"><![CDATA[<p>要论Java最强IDE，还得eclipse。在实际开发过程中，一般来说，我们的项目或多或少的都会引用一些外部jar包，如果可以查看jar包的源代码，对于我们的调试可以说是事半功倍。有时会遇到需要查看类的源代码问题，这时候就需要添加一个非常好用的插件了，用来反编译。<br><a id="more"></a></p><ol><li><p><strong>下载并安装jad.exe</strong>。将jad.exe解压到任意文件目录（建议英文目录），例如：D:\Program Files\eclipse-mars2-64位\jad\jad.exe。</p></li><li><p><strong>安装jadclipse插件</strong>。下载并解压net.sf.jadclipse_3.3.0.jar（根据自己的eclipse版本下载合适的jar包，如何查看eclipse版本？help–about eclipse–release）,将其拷贝到eclipse\plugins目录下，重新启动eclipse。</p></li><li><p><strong>配置jadclipse</strong>。在eclipse窗口下，点击Window &gt; Preferences &gt; Java &gt; JadClipse &gt; Path to Decompiler。（设置jad的绝对路径，例如 D:\Program Files\eclipse-mars2-64位\jad\jad.exe) 可将Use Eclipse code formatter(overrides Jad formatting instructions)选项打勾，这样可以与Ctrl+Shif+F格式化出来的代码样式一致。执行完这几个步骤，再在导入自Jar包的类或者方法上点击查看，就可以查看源代码了。</p></li><li><strong>如果不能，参考下面的解决办法：</strong><br>多数情况下，是eclipse未能自动将JadClipse Class File Viewer设置成class文件的缺省打开方式。在Eclipse的Windows——&gt; Perference——&gt;General-&gt;Editors-&gt;File Associations中修改“*.class”和“*.class without source”默认关联的编辑器为“JadClipse Class File Viewer”。</li></ol><p>下载地址：<br>jadclipse：<a href="http://jadclipse.sourceforge.net/wiki/index.php/Main_Page#Download" target="_blank" rel="noopener">http://jadclipse.sourceforge.net/wiki/index.php/Main_Page#Download</a><br>jad.exe： <a href="https://varaneckas.com/jad/" target="_blank" rel="noopener">https://varaneckas.com/jad/</a></p>]]></content>
      
      <categories>
          
          <category> eclipse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 eclipse </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java排序算法汇总</title>
      <link href="/2018/04/18/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <content type="html"><![CDATA[<p><strong>目录</strong></p><p>[TOC]<br><a id="more"></a></p><p>##1.介绍<br>排序是计算机经常进行的操作，目的是将一些无序的数调整为有序的序列。排序分为分内部排序和外部排序。若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序。反之，若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，则称此类排序问题为外部排序。</p><p>###1.1分类<br>稳定排序：假设在待排序的文件中，存在两个或两个以上的记录具有相同的关键字，在用某种排序法排序后，若这些相同关键字的元素的相对次序仍然不变，则这种排序方法是稳定的。其中冒泡，插入，基数，归并属于稳定排序，选择，快速，希尔，堆属于不稳定排序。<br>就地排序：若排序算法所需的辅助空间并不依赖于问题的规模n，即辅助空间为O（1）,则称为就地排序。（百度百科）</p><p>##2.交换排序</p><p>###2.1冒泡排序<br>已知一组无序数据a[1]、a[2]、……a[n]，需将其按升序排列。首先比较a[1]与a[2]的值，若a[1]大于a[2]则交换两者的值，否则不变。再比较a[2]与a[3]的值，若a[2]大于a[3]则交换两者的值，否则不变。再比较a[3]与a[4]，以此类推，最后比较a[n-1]与a[n]的值。这样处理一轮后，a[n]的值一定是这组数据中最大的。再对a[1]~a[n-1]以相同方法处理一轮，则a[n-1]的值一定是a[1]~a[n-1]中最大的。以此类推，共处理n-1轮后a[1]、a[2]、……a[n]就以升序排列了。降序排列与升序排列相类似，只需要改变判定条件，其他的都可以不用变。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">    <span class="comment">//比较相邻的两个数，若后者小于前者，则交换两者的位置</span></span><br><span class="line"><span class="keyword">if</span>(arr[j]&lt;arr[i])&#123;</span><br><span class="line">temp=arr[j];</span><br><span class="line">arr[j]=arr[i];</span><br><span class="line">arr[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr= <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">BubbleSort(arr);</span><br><span class="line">output(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>时间复杂度：理想情况下（数组本来就是有序的），此时最好的时间复杂度为O(n),最坏的时间复杂度(数据反序的)，此时的时间复杂度为O(n^2) 。冒泡排序的平均时间负责度为O(n^2).</p><p>###2.2快速排序<br>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。<br>一趟快速排序的算法是：<br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QiuckSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line"><span class="keyword">int</span> i=low-<span class="number">1</span>,j=high+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid=arr[(low+high)/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(arr[++i]&lt;mid&amp;&amp;i&lt;high);</span><br><span class="line"><span class="keyword">while</span>(arr[--j]&gt;mid&amp;&amp;j&gt;low);</span><br><span class="line"><span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换位置</span></span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line">arr[i]=arr[j];</span><br><span class="line">arr[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归排序</span></span><br><span class="line">QiuckSort(arr, low, i-<span class="number">1</span>);</span><br><span class="line">QiuckSort(arr, j+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QiuckSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">output(arr);</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>##3.插入排序</p><p>###3.1直接插入排序<br>每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。<br>第一趟比较前两个数，然后把第二个数按大小插入到有序表中； 第二趟把第三个数据与前两个数从前向后扫描，把第三个数按大小插入到有序表中；依次进行下去，进行了(n-1)趟扫描以后就完成了整个排序过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="comment">//直接插入排序是将待比较的数值与它的前一个数值进行比较，所以外层循环是从第二个数值开始的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="comment">//如果当前元素小于其前面的元素</span></span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;arr[i-<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//用一个变量来保存当前待比较的数值，因为当一趟比较完成时，我们要将待比较数值置入比它小的数值的后一位 </span></span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line"><span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;arr[j];j--)&#123;</span><br><span class="line">arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">&#125;</span><br><span class="line">arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InsertSort(arr);//插入排序</span><br></pre></td></tr></table></figure></p><p>测试结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>###3.2希尔排序<br>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量 =1( &lt; …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。<br>该方法实质上是一种分组插入方法<br>比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比[2] 较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。<br>一般的初次取序列的一半为增量，以后每次减半，直到增量为1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> h=len/<span class="number">2</span>;h&gt;<span class="number">0</span>;h=h/<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line"><span class="keyword">if</span>(temp&lt;arr[i-h])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j+=h)&#123;</span><br><span class="line"><span class="keyword">if</span>(temp&lt;arr[j])&#123;</span><br><span class="line">temp=arr[j];</span><br><span class="line">arr[j]=arr[i];</span><br><span class="line">arr[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ShellSort(arr);//希尔排序</span><br></pre></td></tr></table></figure></p><p>测试结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>##4.选择排序</p><p>###4.1简单选择排序<br>在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。<br>最坏情况下，即待排序记录初始状态是按逆序排列的，则需要移动记录的次数最多为3（n-1）。简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。当=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，共需要进行的比较次数是(n-1)+(n-2)+…+2+1=n(n-1)/2，即进行比较操作的时间复杂度为O(n^2)，进行移动操作的时间复杂度为O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SimpleSelectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">k=i;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&lt;arr[i])&#123;</span><br><span class="line">k=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k!=i)&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[k];</span><br><span class="line">arr[k]=arr[i];</span><br><span class="line">arr[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleSelectSort(arr);//简单选择排序</span><br><span class="line">output(arr);</span><br></pre></td></tr></table></figure></p><p>测试结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 3 5 7 6 8 9</span><br></pre></td></tr></table></figure></p><p>###4.2堆排序<br>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">HeapCreate</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> parent,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[parent],child=<span class="number">2</span>*parent+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(child&lt;length)&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span>&lt;length&amp;&amp;arr[child]&lt;arr[child+<span class="number">1</span>]) child++;</span><br><span class="line"><span class="keyword">if</span>(temp&gt;=arr[child])&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[parent]=arr[child];</span><br><span class="line">parent=child;</span><br><span class="line">child=parent*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[parent]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> top)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">HeapCreate(arr, i, arr.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;=arr.length-top;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>]=arr[i];</span><br><span class="line">arr[i]=temp;</span><br><span class="line">HeapCreate(arr, <span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HeapSort(arr, arr.length);<span class="comment">//堆排序</span></span><br><span class="line">output(arr);</span><br></pre></td></tr></table></figure></p><p>测试结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>##5.归并排序<br>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p><p>归并操作(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。<br>如　设有数列{6，202，100，301，38，8，1}<br>初始状态：6,202,100,301,38,8，1<br>第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；<br>第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；<br>第三次归并后：{1,6,8,38,100,202,301},比较次数：4；<br>总的比较次数为：3+4+4=11,；<br>逆序数为14；</p><p>归并操作的工作原理如下：<br>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针超出序列尾<br>将另一序列剩下的所有元素直接复制到合并序列尾<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merger</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> first,<span class="keyword">int</span> mid,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">Queue&lt;Integer&gt; tempV = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">int</span> indexA,indexB;</span><br><span class="line"><span class="comment">//设置indexA，并扫描subArray1 [first,mid]</span></span><br><span class="line"><span class="comment">//设置indexB,并扫描subArray2 [mid,last]</span></span><br><span class="line">indexA=first;indexB=mid;</span><br><span class="line"><span class="comment">//在没有比较完两个子标的情况下，比较 v[indexA]和v[indexB]</span></span><br><span class="line"><span class="comment">//将其中小的放到临时变量tempV中</span></span><br><span class="line"><span class="keyword">while</span>(indexA&lt;mid &amp;&amp; indexB&lt;last)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[indexA]&lt;arr[indexB])&#123;</span><br><span class="line">tempV.offer(arr[indexA]);</span><br><span class="line">indexA++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tempV.offer(arr[indexB]);</span><br><span class="line">indexB++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//复制没有比较完子表中的元素</span></span><br><span class="line"><span class="keyword">while</span>(indexA&lt;mid)&#123;</span><br><span class="line">tempV.offer(arr[indexA]);</span><br><span class="line">indexA++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(indexB&lt;last)&#123;</span><br><span class="line">tempV.offer(arr[indexB]);</span><br><span class="line">indexB++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(tempV.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">arr[first+index]=tempV.poll();</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(first+<span class="number">1</span>&lt;last)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(first+last)/<span class="number">2</span>;</span><br><span class="line">MergerSort(arr, first, mid);</span><br><span class="line">MergerSort(arr, mid, last);</span><br><span class="line">Merger(arr, first, mid, last);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MergerSort(arr, <span class="number">0</span>, arr.length);<span class="comment">//归并排序</span></span><br><span class="line">output(arr);</span><br></pre></td></tr></table></figure></p><p>测试结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>##6.基数排序<br>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约定:待排数字中没有0,如果某桶内数字为0则表示该桶未被使用,输出时跳过即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> array_x=<span class="number">10</span>,array_y=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array_x;i++)&#123;</span><br><span class="line"><span class="keyword">int</span>[][] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[array_x][array_y];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item :  arr) &#123;</span><br><span class="line"><span class="keyword">int</span> temp=(item/(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i))%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;array_y;m++)&#123;</span><br><span class="line"><span class="keyword">if</span>(bucket[temp][m]==<span class="number">0</span>)&#123;</span><br><span class="line">bucket[temp][m]=item;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>,x=<span class="number">0</span>;x&lt;array_x&amp;&amp;n&lt;arr.length;x++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;array_y;y++)&#123;</span><br><span class="line"><span class="keyword">if</span>(bucket[x][y]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">arr[n++]=bucket[x][y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RadixSort(arr);<span class="comment">//基数排序</span></span><br><span class="line">output(arr);</span><br></pre></td></tr></table></figure></p><p>测试结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>##7.总结<br>以上就是各种排序算法，有误之处还望不吝赐教。以下是Java代码汇总(有点长，不要轻易点击哦)<br><!--more--><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortMethod</span> </span>&#123;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&lt;arr[i])&#123;</span><br><span class="line">temp=arr[j];</span><br><span class="line">arr[j]=arr[i];</span><br><span class="line">arr[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QiuckSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line"><span class="keyword">int</span> i=low-<span class="number">1</span>,j=high+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid=arr[(low+high)/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(arr[++i]&lt;mid&amp;&amp;i&lt;high);</span><br><span class="line"><span class="keyword">while</span>(arr[--j]&gt;mid&amp;&amp;j&gt;low);</span><br><span class="line"><span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换位置</span></span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line">arr[i]=arr[j];</span><br><span class="line">arr[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归排序</span></span><br><span class="line">QiuckSort(arr, low, i-<span class="number">1</span>);</span><br><span class="line">QiuckSort(arr, j+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="comment">//直接插入排序是将待比较的数值与它的前一个数值进行比较，所以外层循环是从第二个数值开始的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="comment">//如果当前元素小于其前面的元素</span></span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;arr[i-<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//用一个变量来保存当前待比较的数值，因为当一趟比较完成时，我们要将待比较数值置入比它小的数值的后一位 </span></span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line"><span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;arr[j];j--)&#123;</span><br><span class="line">arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">&#125;</span><br><span class="line">arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> h=len/<span class="number">2</span>;h&gt;<span class="number">0</span>;h=h/<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line"><span class="keyword">if</span>(temp&lt;arr[i-h])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j+=h)&#123;</span><br><span class="line"><span class="keyword">if</span>(temp&lt;arr[j])&#123;</span><br><span class="line">temp=arr[j];</span><br><span class="line">arr[j]=arr[i];</span><br><span class="line">arr[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SimpleSelectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">k=i;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&lt;arr[i])&#123;</span><br><span class="line">k=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k!=i)&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[k];</span><br><span class="line">arr[k]=arr[i];</span><br><span class="line">arr[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">HeapCreate</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> parent,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[parent],child=<span class="number">2</span>*parent+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(child&lt;length)&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span>&lt;length&amp;&amp;arr[child]&lt;arr[child+<span class="number">1</span>]) child++;</span><br><span class="line"><span class="keyword">if</span>(temp&gt;=arr[child])&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[parent]=arr[child];</span><br><span class="line">parent=child;</span><br><span class="line">child=parent*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[parent]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> top)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">HeapCreate(arr, i, arr.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;=arr.length-top;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>]=arr[i];</span><br><span class="line">arr[i]=temp;</span><br><span class="line">HeapCreate(arr, <span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merger</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> first,<span class="keyword">int</span> mid,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">Queue&lt;Integer&gt; tempV = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">int</span> indexA,indexB;</span><br><span class="line"><span class="comment">//设置indexA，并扫描subArray1 [first,mid]</span></span><br><span class="line"><span class="comment">//设置indexB,并扫描subArray2 [mid,last]</span></span><br><span class="line">indexA=first;indexB=mid;</span><br><span class="line"><span class="comment">//在没有比较完两个子标的情况下，比较 v[indexA]和v[indexB]</span></span><br><span class="line"><span class="comment">//将其中小的放到临时变量tempV中</span></span><br><span class="line"><span class="keyword">while</span>(indexA&lt;mid &amp;&amp; indexB&lt;last)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[indexA]&lt;arr[indexB])&#123;</span><br><span class="line">tempV.offer(arr[indexA]);</span><br><span class="line">indexA++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tempV.offer(arr[indexB]);</span><br><span class="line">indexB++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//复制没有比较完子表中的元素</span></span><br><span class="line"><span class="keyword">while</span>(indexA&lt;mid)&#123;</span><br><span class="line">tempV.offer(arr[indexA]);</span><br><span class="line">indexA++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(indexB&lt;last)&#123;</span><br><span class="line">tempV.offer(arr[indexB]);</span><br><span class="line">indexB++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(tempV.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">arr[first+index]=tempV.poll();</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(first+<span class="number">1</span>&lt;last)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(first+last)/<span class="number">2</span>;</span><br><span class="line">MergerSort(arr, first, mid);</span><br><span class="line">MergerSort(arr, mid, last);</span><br><span class="line">Merger(arr, first, mid, last);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="comment">// 约定:待排数字中没有0,如果某桶内数字为0则表示该桶未被使用,输出时跳过即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> array_x=<span class="number">10</span>,array_y=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array_x;i++)&#123;</span><br><span class="line"><span class="keyword">int</span>[][] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[array_x][array_y];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item :  arr) &#123;</span><br><span class="line"><span class="keyword">int</span> temp=(item/(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i))%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;array_y;m++)&#123;</span><br><span class="line"><span class="keyword">if</span>(bucket[temp][m]==<span class="number">0</span>)&#123;</span><br><span class="line">bucket[temp][m]=item;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>,x=<span class="number">0</span>;x&lt;array_x&amp;&amp;n&lt;arr.length;x++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;array_y;y++)&#123;</span><br><span class="line"><span class="keyword">if</span>(bucket[x][y]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">arr[n++]=bucket[x][y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr= <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="comment">//BubbleSort(arr);//冒泡排序</span></span><br><span class="line"><span class="comment">//QiuckSort(arr, 0, arr.length-1);//快速排序</span></span><br><span class="line"><span class="comment">//InsertSort(arr);//插入排序</span></span><br><span class="line"><span class="comment">//ShellSort(arr);//希尔排序</span></span><br><span class="line"><span class="comment">//SimpleSelectSort(arr);//简单选择排序</span></span><br><span class="line"><span class="comment">//HeapSort(arr, arr.length);//堆排序</span></span><br><span class="line"><span class="comment">//MergerSort(arr, 0, arr.length);//归并排序</span></span><br><span class="line">RadixSort(arr);<span class="comment">//基数排序</span></span><br><span class="line">output(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown 使用注意点</title>
      <link href="/2018/04/18/Markdown-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <content type="html"><![CDATA[<hr><p>##1.关于目录<br>目录的用处在于帮助读者浏览大致内容和快速定位到想看的内容，markdown语法中支持目录的操作。在你想要插入目录的地方<strong>换行并空一行,即保证 <code>[TOC]</code>前面有一个空行</strong>，然后输入 <code>[TOC]</code> 即可看到相应的文章目录，之后添加的多级标题都可以自动添加到目录。</p><p>[TOC]<br><a id="more"></a></p><p>##2.关于表格<br>使用|分割，表头下面加上短横线（至少需要一个短线），示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|姓名|年龄|工资|工龄|</span><br><span class="line">|-|</span><br><span class="line">|张三|20|1200|5|</span><br><span class="line">|李四|18|2300|6|</span><br><span class="line">|王五|23|2343|7|</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>姓名</th><th>年龄</th><th>工资</th><th>工龄</th></tr></thead><tbody><tr><td>张三</td><td>20</td><td>1200</td><td>5</td></tr><tr><td>李四</td><td>18</td><td>2300</td><td>6</td></tr><tr><td>王五</td><td>23</td><td>2343</td><td>7</td></tr></tbody></table><p>##3.关于注脚<br>注脚的使用可方便在文末注明一些额外的信息，使用前应该<strong>先定义</strong></p><ul><li>定义格式： [^定义名]: 解释内容</li><li><p>使用格式： 在需要使用注脚的内容后面加上[^定义名] 就好了<br>示例：<br>这是注脚1<a href="注脚1">^footnote</a><br>##4.关于无序列表<br>-、+、*都可以表示无序列表，在使用时，也应该<strong>换行后空行</strong>，然后用空格隔开表示无序列表。<br>示例：</p></li><li><p>无序列表一</p></li><li>无序列表二</li></ul>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
