<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[为eclipse添加反编译插件]]></title>
    <url>%2F2018%2F04%2F24%2F%E4%B8%BAeclipse%E6%B7%BB%E5%8A%A0%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[要论Java最强IDE，还得eclipse。在实际开发过程中，一般来说，我们的项目或多或少的都会引用一些外部jar包，如果可以查看jar包的源代码，对于我们的调试可以说是事半功倍。有时会遇到需要查看类的源代码问题，这时候就需要添加一个非常好用的插件了，用来反编译。 下载并安装jad.exe。将jad.exe解压到任意文件目录（建议英文目录），例如：D:\Program Files\eclipse-mars2-64位\jad\jad.exe。 安装jadclipse插件。下载并解压net.sf.jadclipse_3.3.0.jar（根据自己的eclipse版本下载合适的jar包，如何查看eclipse版本？help–about eclipse–release）,将其拷贝到eclipse\plugins目录下，重新启动eclipse。 配置jadclipse。在eclipse窗口下，点击Window &gt; Preferences &gt; Java &gt; JadClipse &gt; Path to Decompiler。（设置jad的绝对路径，例如 D:\Program Files\eclipse-mars2-64位\jad\jad.exe) 可将Use Eclipse code formatter(overrides Jad formatting instructions)选项打勾，这样可以与Ctrl+Shif+F格式化出来的代码样式一致。执行完这几个步骤，再在导入自Jar包的类或者方法上点击查看，就可以查看源代码了。 如果不能，参考下面的解决办法：多数情况下，是eclipse未能自动将JadClipse Class File Viewer设置成class文件的缺省打开方式。在Eclipse的Windows——&gt; Perference——&gt;General-&gt;Editors-&gt;File Associations中修改“*.class”和“*.class without source”默认关联的编辑器为“JadClipse Class File Viewer”。 下载地址：jadclipse：http://jadclipse.sourceforge.net/wiki/index.php/Main_Page#Downloadjad.exe： https://varaneckas.com/jad/]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>随笔 eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java排序算法汇总]]></title>
    <url>%2F2018%2F04%2F18%2FJava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[目录 [TOC] ##1.介绍排序是计算机经常进行的操作，目的是将一些无序的数调整为有序的序列。排序分为分内部排序和外部排序。若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序。反之，若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，则称此类排序问题为外部排序。 ###1.1分类稳定排序：假设在待排序的文件中，存在两个或两个以上的记录具有相同的关键字，在用某种排序法排序后，若这些相同关键字的元素的相对次序仍然不变，则这种排序方法是稳定的。其中冒泡，插入，基数，归并属于稳定排序，选择，快速，希尔，堆属于不稳定排序。就地排序：若排序算法所需的辅助空间并不依赖于问题的规模n，即辅助空间为O（1）,则称为就地排序。（百度百科） ##2.交换排序 ###2.1冒泡排序已知一组无序数据a[1]、a[2]、……a[n]，需将其按升序排列。首先比较a[1]与a[2]的值，若a[1]大于a[2]则交换两者的值，否则不变。再比较a[2]与a[3]的值，若a[2]大于a[3]则交换两者的值，否则不变。再比较a[3]与a[4]，以此类推，最后比较a[n-1]与a[n]的值。这样处理一轮后，a[n]的值一定是这组数据中最大的。再对a[1]~a[n-1]以相同方法处理一轮，则a[n-1]的值一定是a[1]~a[n-1]中最大的。以此类推，共处理n-1轮后a[1]、a[2]、……a[n]就以升序排列了。降序排列与升序排列相类似，只需要改变判定条件，其他的都可以不用变。1234567891011121314//冒泡排序 public static void BubbleSort(int[] arr)&#123; int temp; for(int i=0;i&lt;arr.length-1;i++)&#123; for(int j=i+1;j&lt;arr.length;j++)&#123; //比较相邻的两个数，若后者小于前者，则交换两者的位置 if(arr[j]&lt;arr[i])&#123; temp=arr[j]; arr[j]=arr[i]; arr[i]=temp; &#125; &#125; &#125; &#125; 测试代码12345public static void main(String[] args)&#123; int[] arr= new int[] &#123;2,3,5,1,4,9,6,8,7&#125;; BubbleSort(arr); output(arr); &#125; 运行结果11 2 3 4 5 6 7 8 9 时间复杂度：理想情况下（数组本来就是有序的），此时最好的时间复杂度为O(n),最坏的时间复杂度(数据反序的)，此时的时间复杂度为O(n^2) 。冒泡排序的平均时间负责度为O(n^2). ###2.2快速排序设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。一趟快速排序的算法是：1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。123456789101112131415161718192021//快速排序 public static void QiuckSort(int[] arr,int low,int high)&#123; if(low&lt;high)&#123; int i=low-1,j=high+1; int mid=arr[(low+high)/2]; while(true)&#123; while(arr[++i]&lt;mid&amp;&amp;i&lt;high); while(arr[--j]&gt;mid&amp;&amp;j&gt;low); if(i&gt;=j)&#123; break; &#125; //交换位置 int temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; &#125; //递归排序 QiuckSort(arr, low, i-1); QiuckSort(arr, j+1, high); &#125; &#125; 简单测试12QiuckSort(arr, 0, arr.length-1);output(arr); 运行结果11 2 3 4 5 6 7 8 9 ##3.插入排序 ###3.1直接插入排序每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。第一趟比较前两个数，然后把第二个数按大小插入到有序表中； 第二趟把第三个数据与前两个数从前向后扫描，把第三个数按大小插入到有序表中；依次进行下去，进行了(n-1)趟扫描以后就完成了整个排序过程。123456789101112131415public static void InsertSort(int[] arr)&#123; //直接插入排序是将待比较的数值与它的前一个数值进行比较，所以外层循环是从第二个数值开始的 for(int i=1;i&lt;arr.length;i++)&#123; //如果当前元素小于其前面的元素 if(arr[i]&lt;arr[i-1])&#123; int j=0; //用一个变量来保存当前待比较的数值，因为当一趟比较完成时，我们要将待比较数值置入比它小的数值的后一位 int temp=arr[i]; for(j=i-1;j&gt;=0&amp;&amp;temp&lt;arr[j];j--)&#123; arr[j+1]=arr[j]; &#125; arr[j+1]=temp; &#125; &#125; &#125; 简单测试1InsertSort(arr);//插入排序 测试结果11 2 3 4 5 6 7 8 9 ###3.2希尔排序先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量 =1( &lt; …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比[2] 较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。一般的初次取序列的一半为增量，以后每次减半，直到增量为1。1234567891011121314151617public static void ShellSort(int[] arr)&#123; int len=arr.length; for(int h=len/2;h&gt;0;h=h/2)&#123; for(int i=h;i&lt;len;i++)&#123; int temp=arr[i]; if(temp&lt;arr[i-h])&#123; for(int j=0;j&lt;i;j+=h)&#123; if(temp&lt;arr[j])&#123; temp=arr[j]; arr[j]=arr[i]; arr[i]=temp; &#125; &#125; &#125; &#125; &#125; &#125; 简单测试1ShellSort(arr);//希尔排序 测试结果11 2 3 4 5 6 7 8 9 ##4.选择排序 ###4.1简单选择排序在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。最坏情况下，即待排序记录初始状态是按逆序排列的，则需要移动记录的次数最多为3（n-1）。简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。当=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，共需要进行的比较次数是(n-1)+(n-2)+…+2+1=n(n-1)/2，即进行比较操作的时间复杂度为O(n^2)，进行移动操作的时间复杂度为O(n)。 1234567891011121314151617//简单选择排序 public static void SimpleSelectSort(int[] arr)&#123; int i,j,k; for(i=0;i&lt;arr.length-1;i++)&#123; k=i; for(j=i+1;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[i])&#123; k=j; &#125; &#125; if(k!=i)&#123; int temp=arr[k]; arr[k]=arr[i]; arr[i]=temp; &#125; &#125; &#125; 简单测试12SimpleSelectSort(arr);//简单选择排序output(arr); 测试结果11 2 4 3 5 7 6 8 9 ###4.2堆排序堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。1234567891011121314151617181920212223242526//构建堆 public static void HeapCreate(int[] arr,int parent,int length)&#123; int temp=arr[parent],child=2*parent+1; while(child&lt;length)&#123; if(child+1&lt;length&amp;&amp;arr[child]&lt;arr[child+1]) child++; if(temp&gt;=arr[child])&#123; break; &#125; arr[parent]=arr[child]; parent=child; child=parent*2+1; &#125; arr[parent]=temp; &#125; //堆排序 public static void HeapSort(int[] arr,int top)&#123; for(int i=arr.length/2-1;i&gt;=0;i--)&#123; HeapCreate(arr, i, arr.length); &#125; for(int i=arr.length-1;i&gt;=arr.length-top;i--)&#123; int temp=arr[0]; arr[0]=arr[i]; arr[i]=temp; HeapCreate(arr, 0, i); &#125; &#125; 简单测试12HeapSort(arr, arr.length);//堆排序output(arr); 测试结果11 2 3 4 5 6 7 8 9 ##5.归并排序归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。 归并操作(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。如 设有数列{6，202，100，301，38，8，1}初始状态：6,202,100,301,38,8，1第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；第三次归并后：{1,6,8,38,100,202,301},比较次数：4；总的比较次数为：3+4+4=11,；逆序数为14； 归并操作的工作原理如下：第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾123456789101112131415161718192021222324252627282930313233343536373839404142//归并排序 public static void Merger(int[] arr,int first,int mid,int last)&#123; Queue&lt;Integer&gt; tempV = new LinkedList&lt;Integer&gt;(); int indexA,indexB; //设置indexA，并扫描subArray1 [first,mid] //设置indexB,并扫描subArray2 [mid,last] indexA=first;indexB=mid; //在没有比较完两个子标的情况下，比较 v[indexA]和v[indexB] //将其中小的放到临时变量tempV中 while(indexA&lt;mid &amp;&amp; indexB&lt;last)&#123; if(arr[indexA]&lt;arr[indexB])&#123; tempV.offer(arr[indexA]); indexA++; &#125; else &#123; tempV.offer(arr[indexB]); indexB++; &#125; &#125; //复制没有比较完子表中的元素 while(indexA&lt;mid)&#123; tempV.offer(arr[indexA]); indexA++; &#125; while(indexB&lt;last)&#123; tempV.offer(arr[indexB]); indexB++; &#125; int index=0; while(tempV.size()&gt;0)&#123; arr[first+index]=tempV.poll(); index++; &#125; &#125; public static void MergerSort(int[] arr,int first,int last)&#123; if(first+1&lt;last)&#123; int mid=(first+last)/2; MergerSort(arr, first, mid); MergerSort(arr, mid, last); Merger(arr, first, mid, last); &#125; &#125; 简单测试12MergerSort(arr, 0, arr.length);//归并排序output(arr); 测试结果11 2 3 4 5 6 7 8 9 ##6.基数排序基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。12345678910111213141516171819202122// 约定:待排数字中没有0,如果某桶内数字为0则表示该桶未被使用,输出时跳过即可 public static void RadixSort(int[] arr)&#123; int array_x=10,array_y=100; for(int i=0;i&lt;array_x;i++)&#123; int[][] bucket=new int[array_x][array_y]; for (int item : arr) &#123; int temp=(item/(int)Math.pow(10, i))%10; for(int m=0;m&lt;array_y;m++)&#123; if(bucket[temp][m]==0)&#123; bucket[temp][m]=item; break; &#125; &#125; &#125; for(int n=0,x=0;x&lt;array_x&amp;&amp;n&lt;arr.length;x++)&#123; for(int y=0;y&lt;array_y;y++)&#123; if(bucket[x][y]==0) continue; arr[n++]=bucket[x][y]; &#125; &#125; &#125; &#125; 简单测试12RadixSort(arr);//基数排序output(arr); 测试结果11 2 3 4 5 6 7 8 9 ##7.总结以上就是各种排序算法，有误之处还望不吝赐教。以下是Java代码汇总(有点长，不要轻易点击哦)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200import java.util.LinkedList;import java.util.List;import java.util.Queue;//排序算法public class SortMethod &#123; //冒泡排序 public static void BubbleSort(int[] arr)&#123; int temp; for(int i=0;i&lt;arr.length-1;i++)&#123; for(int j=i+1;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[i])&#123; temp=arr[j]; arr[j]=arr[i]; arr[i]=temp; &#125; &#125; &#125; &#125; //快速排序 public static void QiuckSort(int[] arr,int low,int high)&#123; if(low&lt;high)&#123; int i=low-1,j=high+1; int mid=arr[(low+high)/2]; while(true)&#123; while(arr[++i]&lt;mid&amp;&amp;i&lt;high); while(arr[--j]&gt;mid&amp;&amp;j&gt;low); if(i&gt;=j)&#123; break; &#125; //交换位置 int temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; &#125; //递归排序 QiuckSort(arr, low, i-1); QiuckSort(arr, j+1, high); &#125; &#125; //插入排序 public static void InsertSort(int[] arr)&#123; //直接插入排序是将待比较的数值与它的前一个数值进行比较，所以外层循环是从第二个数值开始的 for(int i=1;i&lt;arr.length;i++)&#123; //如果当前元素小于其前面的元素 if(arr[i]&lt;arr[i-1])&#123; int j=0; //用一个变量来保存当前待比较的数值，因为当一趟比较完成时，我们要将待比较数值置入比它小的数值的后一位 int temp=arr[i]; for(j=i-1;j&gt;=0&amp;&amp;temp&lt;arr[j];j--)&#123; arr[j+1]=arr[j]; &#125; arr[j+1]=temp; &#125; &#125; &#125; //希尔排序 public static void ShellSort(int[] arr)&#123; int len=arr.length; for(int h=len/2;h&gt;0;h=h/2)&#123; for(int i=h;i&lt;len;i++)&#123; int temp=arr[i]; if(temp&lt;arr[i-h])&#123; for(int j=0;j&lt;i;j+=h)&#123; if(temp&lt;arr[j])&#123; temp=arr[j]; arr[j]=arr[i]; arr[i]=temp; &#125; &#125; &#125; &#125; &#125; &#125; //简单选择排序 public static void SimpleSelectSort(int[] arr)&#123; int i,j,k; for(i=0;i&lt;arr.length-1;i++)&#123; k=i; for(j=i+1;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[i])&#123; k=j; &#125; &#125; if(k!=i)&#123; int temp=arr[k]; arr[k]=arr[i]; arr[i]=temp; &#125; &#125; &#125; //构建堆 public static void HeapCreate(int[] arr,int parent,int length)&#123; int temp=arr[parent],child=2*parent+1; while(child&lt;length)&#123; if(child+1&lt;length&amp;&amp;arr[child]&lt;arr[child+1]) child++; if(temp&gt;=arr[child])&#123; break; &#125; arr[parent]=arr[child]; parent=child; child=parent*2+1; &#125; arr[parent]=temp; &#125; //堆排序 public static void HeapSort(int[] arr,int top)&#123; for(int i=arr.length/2-1;i&gt;=0;i--)&#123; HeapCreate(arr, i, arr.length); &#125; for(int i=arr.length-1;i&gt;=arr.length-top;i--)&#123; int temp=arr[0]; arr[0]=arr[i]; arr[i]=temp; HeapCreate(arr, 0, i); &#125; &#125; //归并排序 public static void Merger(int[] arr,int first,int mid,int last)&#123; Queue&lt;Integer&gt; tempV = new LinkedList&lt;Integer&gt;(); int indexA,indexB; //设置indexA，并扫描subArray1 [first,mid] //设置indexB,并扫描subArray2 [mid,last] indexA=first;indexB=mid; //在没有比较完两个子标的情况下，比较 v[indexA]和v[indexB] //将其中小的放到临时变量tempV中 while(indexA&lt;mid &amp;&amp; indexB&lt;last)&#123; if(arr[indexA]&lt;arr[indexB])&#123; tempV.offer(arr[indexA]); indexA++; &#125; else &#123; tempV.offer(arr[indexB]); indexB++; &#125; &#125; //复制没有比较完子表中的元素 while(indexA&lt;mid)&#123; tempV.offer(arr[indexA]); indexA++; &#125; while(indexB&lt;last)&#123; tempV.offer(arr[indexB]); indexB++; &#125; int index=0; while(tempV.size()&gt;0)&#123; arr[first+index]=tempV.poll(); index++; &#125; &#125; public static void MergerSort(int[] arr,int first,int last)&#123; if(first+1&lt;last)&#123; int mid=(first+last)/2; MergerSort(arr, first, mid); MergerSort(arr, mid, last); Merger(arr, first, mid, last); &#125; &#125; //基数排序 // 约定:待排数字中没有0,如果某桶内数字为0则表示该桶未被使用,输出时跳过即可 public static void RadixSort(int[] arr)&#123; int array_x=10,array_y=100; for(int i=0;i&lt;array_x;i++)&#123; int[][] bucket=new int[array_x][array_y]; for (int item : arr) &#123; int temp=(item/(int)Math.pow(10, i))%10; for(int m=0;m&lt;array_y;m++)&#123; if(bucket[temp][m]==0)&#123; bucket[temp][m]=item; break; &#125; &#125; &#125; for(int n=0,x=0;x&lt;array_x&amp;&amp;n&lt;arr.length;x++)&#123; for(int y=0;y&lt;array_y;y++)&#123; if(bucket[x][y]==0) continue; arr[n++]=bucket[x][y]; &#125; &#125; &#125; &#125; public static void main(String[] args)&#123; int[] arr= new int[] &#123;2,3,5,1,4,9,6,8,7&#125;; //BubbleSort(arr);//冒泡排序 //QiuckSort(arr, 0, arr.length-1);//快速排序 //InsertSort(arr);//插入排序 //ShellSort(arr);//希尔排序 //SimpleSelectSort(arr);//简单选择排序 //HeapSort(arr, arr.length);//堆排序 //MergerSort(arr, 0, arr.length);//归并排序 RadixSort(arr);//基数排序 output(arr); &#125; public static void output(int[] arr)&#123; for(int i=0;i&lt;arr.length;i++)&#123; System.out.print(arr[i]+" "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 使用注意点]]></title>
    <url>%2F2018%2F04%2F18%2FMarkdown-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[##1.关于目录目录的用处在于帮助读者浏览大致内容和快速定位到想看的内容，markdown语法中支持目录的操作。在你想要插入目录的地方换行并空一行,即保证 [TOC]前面有一个空行，然后输入 [TOC] 即可看到相应的文章目录，之后添加的多级标题都可以自动添加到目录。 [TOC] ##2.关于表格使用|分割，表头下面加上短横线（至少需要一个短线），示例如下12345|姓名|年龄|工资|工龄||-||张三|20|1200|5||李四|18|2300|6||王五|23|2343|7| 姓名 年龄 工资 工龄 张三 20 1200 5 李四 18 2300 6 王五 23 2343 7 ##3.关于注脚注脚的使用可方便在文末注明一些额外的信息，使用前应该先定义 定义格式： [^定义名]: 解释内容 使用格式： 在需要使用注脚的内容后面加上[^定义名] 就好了示例：这是注脚1^footnote##4.关于无序列表-、+、*都可以表示无序列表，在使用时，也应该换行后空行，然后用空格隔开表示无序列表。示例： 无序列表一 无序列表二]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的知识点]]></title>
    <url>%2F2018%2F04%2F17%2FJava%E4%B8%AD%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
